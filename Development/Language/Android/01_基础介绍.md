技术基础介绍
========================

# Android架构
>android应用开发框架是 Application Framework. 其系统架构由5部分组成，分别是：Linux Kernel、Android Runtime、Libraries、Application Framework、Applications。第二部分将详细介绍这5个部分。下面自底向上分析各层。

![](/images/2017/06/AndroidLayout.jpg)

## 1、Linux Kernel
Android基于Linux 2.6提供核心系统服务，例如：安全、内存管理、进程管理、网络 堆栈、驱动模型。Linux Kernel也作为硬件和软件之间的抽象层，它隐藏具体硬件细节而为上层提供统一的服务。 如果你学过计算机网络知道OSI/RM，就会知道分层的好处就是使用下层提供的服务而为上层提供统一的服务，屏蔽本层及以下层的差异，当本层及以下层发生了变化不会影响到上层。也就是说各层各尽其职，各层提供固定的SAP（Service Access Point），专业点可以说是高内聚、低耦合。 如果你只是做应用开发，就不需要深入了解Linux Kernel层。

## 2、Android Runtime
Android包含一个核心库的集合，提供大部分在Java编程语言核心类库中可用的功能。每一个Android应用程序是Dalvik虚拟机中的实例，运行在他们自己的进程中。Dalvik虚拟机设计成，在一个设备可以高效地运行多个虚拟机。Dalvik虚拟机可执行文件格式是.dex，dex格式是专为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统。 大多数虚拟机包括JVM都是基于栈的，而Dalvik虚拟机则是基于寄存器的。两种架构各有优劣，一般而言，基于栈的机器需要更多指令，而基于寄存器的机器指令更大。dx 是一套工具，可以将 Java .class 转换成 .dex 格式。一个dex文件通常会有多个.class。由于dex有时必须进行最佳化，会使文件大小增加1-4倍，以ODEX结尾。 Dalvik虚拟机依赖于Linux 内核提供基本功能，如线程和底层内存管理。

## 3、Libraries
Android包含一个C/C++库的集合，供Android系统的各个组件使用。这些功能通过Android的应用程序框架（application framework）暴露给开发者。下面列出一些核心库： 系统C库--标准C系统库（libc）的BSD衍生，调整为基于嵌入式Linux设备 媒体库--基于PacketVideo的OpenCORE。这些库支持播放和录制许多流行的音频和视频格式，以及静态图像文件，包括MPEG4、 H.264、 MP3、 AAC、 AMR、JPG、 PNG 界面管理--管理访问显示子系统和无缝组合多个应用程序的二维和三维图形层 LibWebCore--新式的Web浏览器引擎,驱动Android 浏览器和内嵌的web视图 SGL--基本的2D图形引擎 3D库--基于OpenGL ES 1.0 APIs的实现。库使用硬件3D加速或包含高度优化的3D软件光栅 FreeType --位图和矢量字体渲染 SQLite --所有应用程序都可以使用的强大而轻量级的关系数据库引擎

## 4、Application Framework
通过提供开放的开发平台，Android使开发者能够编制极其丰富和新颖的应用程序。开发者可以自由地利用设备硬件优势、访问位置信息、运行后台服务、设置闹钟、向状态栏添加通知等等，很多很多。 开发者可以完全使用核心应用程序所使用的框架APIs。应用程序的体系结构旨在简化组件的重用，任何应用程序都能发布他的功能且任何其他应用程序可以使用这些功能（需要服从框架执行的安全限制）。这一机制允许用户替换组件。 所有的应用程序其实是一组服务和系统，包括： 视图（View）--丰富的、可扩展的视图集合，可用于构建一个应用程序。包括包括列表、网格、文本框、按钮，甚至是内嵌的网页浏览器 内容提供者（Content Providers）--使应用程序能访问其他应用程序（如通讯录）的数据，或共享自己的数据 资源管理器（Resource Manager）--提供访问非代码资源，如本地化字符串、图形和布局文件 通知管理器（Notification Manager）--使所有的应用程序能够在状态栏显示自定义警告 活动管理器（Activity Manager）--管理应用程序生命周期,提供通用的导航回退功能

## 5、Applications
Android装配一个核心应用程序集合，包括电子邮件客户端、SMS程序、日历、地图、浏览器、联系人和其他设置。所有应用程序都是用Java编程语言写的。更加丰富的应用程序有待我们去开发！ 从上面我们知道Android的架构是分层的，非常清晰，分工很明确。Android本身是一套软件堆迭(Software Stack)，或称为「软件迭层架构」，迭层主要分成三层：操作系统、中间件、应用程序。

# Android四大组件
## Activity
>Activity是Android程序与用户交互的窗口，从视觉效果来看，一个Activity占据当前的窗口，响应所有窗口事件，具备有控件，菜单等界面元素。从内部逻辑来看，Activity需要为了保持各个界面状态，需要做很多持久化的事情，还需要妥善管理生命周期，和一些转跳逻辑。

### 生命周期
![Activity Life1](/images/2017/06/Activity001.jpg)

![Activity Life2](/images/2017/06/Activity002.jpg)

但是当一个活动的状态发生改变的时候，开发者可以通过调用 onXX() 的方法获取到相关的通知信息。在实现 Activity 类的时候，通过覆盖（ override ）这些方法即可在你需要处理的时候来调用。
1. onCreate ：当活动第一次启动的时候，触发该方法，可以在此时完成活动的初始化工作。
onCreate 方法有一个参数，该参数可以为空（ null ），也可以是之前调用 onSaveInstanceState （）方法保存的状态信息。
2.  onStart ：该方法的触发表示所属活动将被展现给用户。
3.  onResume ：当一个活动和用户发生交互的时候，触发该方法。
4.  onPause ：当一个正在前台运行的活动因为其他的活动需要前台运行而转入后台运行的时候，触发该方法。这时候需要将活动的状态持久化，比如正在编辑的数据库记录等。
5.  onStop ：当一个活动不再需要展示给用户的时候，触发该方法。如果内存紧张，系统会直接结束这个活动，而不会触发 onStop 方法。 所以保存状态信息是应该在onPause时做，而不是onStop时做。活动如果没有在前台运行，都将被停止或者Linux管理进程为了给新的活动预留足够的存储空间而随时结束这些活动。因此对于开发者来说，在设计应用程序的时候，必须时刻牢记这一原则。在一些情况下，**onPause方法或许是活动触发的最后的方法，因此开发者需要在这个时候保存需要保存的信息**。
6. onRestart ：当处于停止状态的活动需要再次展现给用户的时候，触发该方法。
7. onDestroy ：当活动销毁的时候，触发该方法。和 onStop 方法一样，如果内存紧张，系统会直接结束这个活动而不会触发该方法。
8. onSaveInstanceState ：系统调用该方法，允许活动保存之前的状态，比如说在一串字符串中的光标所处的位置等。

一个Activity的销毁顺序:
（情况一）onPause()——><Process Killed>
（情况二）onPause()——>onStop()——><Process Killed>
（情况三）onPause()——>onStop()——>onDestroy()

### Activity栈
上面提到开发者是无法控制Activity的状态的，那Activity的状态又是按照何种逻辑来运作的呢？这就要知道 Activity 栈。每个Activity的状态是由它在Activity栈（是一个后进先出LIFO，包含所有正在运行Activity的队列）中的位置决定的。当一个新的Activity启动时，当前的活动的Activity将会移到Activity栈的顶部。如果用户使用后退按钮返回的话，或者前台的Activity结束，活动的Activity就会被移出栈消亡，而在栈上的上一个活动的Activity将会移上来并变为活动状态。如下图所示：
![](/images/2017/06/Activity003.jpg)

一个应用程序的优先级是受最高优先级的Activity影响的。当决定某个应用程序是否要终结去释放资源，Android内存管理使用栈来决定基于Activity的应用程序的优先级。

### activity的四种加载模式
在android的多activity开发中，activity之间的跳转可能需要有多种方式，有时是普通的生成一个新实例，有时希望跳转到原来某个activity实例，而不是生成大量的重复的activity。加载模式便是决定以哪种方式启动一个跳转到原来某个Activity实例。在android里，有4种activity的启动模式，分别为：
1. ·standard: 标准模式，一调用startActivity()方法就会产生一个新的实例。
2. ·singleTop: 如果已经有一个实例位于Activity栈的顶部时，就不产生新的实例，而只是调用Activity中的newInstance()方法。如果不位于栈顶，会产生一个新的实例。
3. ·singleTask: 会在一个新的task中产生这个实例，以后每次调用都会使用这个，不会去产生新的实例了。
4. ·singleInstance: 这个跟singleTask基本上是一样，只有一个区别：在这个模式下的Activity实例所处的task中，只能有这个activity实例，不能有其他的实例。

这些启动模式可以在功能清单文件AndroidManifest.xml中进行设置，中的launchMode属性。
相关的代码中也有一些标志可以使用,比如我们想只启用一个实例,则可以使用 Intent.FLAG_ACTIVITY_REORDER_TO_FRONT 标志，这个标志表示：如果这个activity已经启动了，就不产生新的activity，而只是把这个activity实例加到栈顶来就可以了。

``` android
Intent intent = new Intent(ReorderFour.this, ReorderTwo.class);
intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
startActivity(intent);
```

## Service
>service就是android系统中的服务，它有这么几个特点：它无法与用户直接进行交互、它必须由用户或者其他程序显式的启动、它的优先级比较高，它比处于前台的应用优先级低，但是比后台的其他应用优先级高，这就决定了当系统因为缺少内存而销毁某些没被利用的资源时，它被销毁的概率很小。

一般我们认为service分为两类，本地service和远程service。
1. 本地service顾名思义，那就是和当前应用在同一个进程中的service，彼此之间拥有共同的内存区域，所以对于某些数据的共享特别的方便和简单；

2. 远程service：主要牵扯到不同进程间的service访问。因为android的系统安全的原因导致了我们在不同的进程间无法使用一般的方式共享数据。在这里android为我们提供了一个AIDL工具。（android interface description language）android接口描述语言。在后边我们将会对其进行详细的介绍。

就是剥离了界面的Activity，它们在很多Android的概念方面比较接近，都是封装一个完整的功能逻辑，通常都是后台长时间运行，接受上层指令，完成相关事务的模块。定义好需要接受的Intent，提供同步或异步的接口，在上层绑定了它后，通过这些接口（很多时候都是RPC的...）进行通信。
![](/images/2017/06/Service001.jpg)

至于startservice和bindservice的使用场景：
1. 通过startservice开启的服务.一旦服务开启, 这个服务和开启他的调用者之间就没有任何的关系了.调用者不可以访问 service里面的方法. 调用者如果被系统回收了或者调用了ondestroy方法, service还会继续存在。

2. 通过bindService开启的服务,服务开启之后,调用者和服务之间 还存在着联系,一旦调用者挂掉了service也会跟着挂掉。

## Broadcast Receiver
>接收一种或者多种Intent跳转做触发事件，接受相关消息，做一些简单的处理，转换成一条Notification，统一了Android的事件广播模式。

BroadcastReceiver 用于异步接收广播Intent。主要有两大类用于接收广播的：

1. 正常广播 Normal broadcasts（用 Context.sendBroadcast()发送）是完全异步的。它们都运行在一个未定义的顺序，通常是在同一时间。这样会更有效，但意味着receiver不能包含所要使用的结果或中止的API。

2. 有序广播 Ordered broadcasts（用 Context.sendOrderedBroadcast()发送）每次被发送到一个receiver。所谓有序，就是每个receiver执行后可以传播到下一个receiver，也可以完全中止传播--不传播给其他receiver。 而receiver运行的顺序可以通过matched intent-filter 里面的android:priority来控制，当priority优先级相同的时候，Receiver以任意的顺序运行。

要注意的是，即使是Normal broadcasts，系统在某些情况下可能会恢复到一次传播给一个receiver。 特别是receiver可能需要创建一个进程，为了避免系统超载，只能一次运行一个receiver。

Broadcast Receiver 并没有提供可视化的界面来显示广播信息。可以使用Notification和Notification Manager来实现可视化的信息的界面，显示广播信息的内容，图标及震动信息。

### 生命周期
一个BroadcastReceiver 对象只有在被调用onReceive(Context, Intent)的才有效的，当从该函数返回后，该对象就无效的了，结束生命周期。

因此从这个特征可以看出，在所调用的onReceive(Context, Intent)函数里，不能有过于耗时的操作，不能使用线程来执行。对于耗时的操作，请start service来完成。因为当得到其他异步操作所返回的结果时，BroadcastReceiver 可能已经无效了。

### 发送Broadcast
理论上创建一个新的Intent并设置action名称，即可调用该函数发送Broadcast给其他监听的Receiver。但根据发送顺序和处理方式不一样，分为以下四种种方式：
1. sendBroadcast()
最普通的发送intent的方式，是一种无序的广播机制，理论上，所有的接受者同时获得该intent的消息， 接受者之间不存在先后顺序， 不能截断/修改intent的数据。 应用普遍使用的就是该方式。

2. sendOrderedBroadcast()
有序的发送广播的机制，所有接受者都可以设置priority ， 按照priority 的大小顺序进行传递， 上一个优先级的接受者，可以截断和修改intent里面的数据。 同时，也可以设置一个最后接收者（总是在最后一个接收到这个intent，用来做一些特定的功能）。

3. sendStickyBroadcast（）和sendStickyOrderedBroadcast（）
Sticky是一种粘性广播。所谓的粘性是指，这个intent 没有周期限制， 一般的intent 只能发送给当前已经注册了这个监听的receiver，一旦发送完毕就会失去作用周期，而粘性广播没有这个限制，即便后来注册的intent也可以收到这个广播。 需要注意的一点是 这种发送方式不会导致ANR， 因为它没有发送时间的限制。**最新android sdk已经废弃**

4. sendBroadcastAsUser和sendOrderedBroadcastAsUser
android 4.2 之后加入了多用户，UserHandle.ALL /UserHandle.CURRENT/ UserHandle.CURRENT_OR_SELF/ UserHandle.OWNER 这就造就了这些发送函数用来区分不同的用户。

发送Broadcast还可以附带接收者权限（receiverPermission），这个permisson需要在发送的应用AndroidManifest.xml进行申明定义权限，同时接收方的AndroidManifest.xml需要申明使用权限
```xml
<!--Sender-->
<permission android:name="com.cosmicx.androidhelloworld.test" android:protectionLevel="normal"/>

<!--Receiver-->
<uses-permission android:name="com.cosmicx.androidhelloworld.test" />
```

### 注册Receiver
注册有两种方式：
1. 静态方式，在AndroidManifest.xml的application里面定义receiver并设置要接收的action。
```xml
<receiver android:name=".SMSReceiver">
    <intent-filter>
        <action android:name="android.provider.Telephony.SMS_RECEIVED" />
    </intent-filter>
</receiver>
```
2. 动态方式, 在activity里面调用函数来注册，和静态的内容差不多。一个形参是receiver，另一个是IntentFilter，其中里面是要接收的action。
**动态注册**需要特别注意的是，在退出程序前要记得调用Context.unregisterReceiver()方法。一般在activity的onStart()里面进行注册, onStop()里面进行注销。官方提醒，如果在Activity.onResume()里面注册了，就必须在Activity.onPause()注销。

要接收某些action，需要在AndroidManifest.xml里面添加相应的permission。例如接收SMS:
```xml
<uses-permission android:name="android.permission.RECEIVE_SMS" />
```

一个receiver可以接收多个action的，即可以有多个intent-filter，需要在onReceive里面对intent.getAction(action name)进行判断。

## Content Provider
提供第三方应用数据的访问方案。可以派生ContentProvider类，对外提供数据，像数据库一样进行选择排序，屏蔽内部数据的存储细节，向外提供统一的接口模型，大大简化了上层应用，对数据的整合提供了更方便的途径。
